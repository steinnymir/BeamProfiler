# -*- coding: utf-8 -*-
"""
Created on Fri June  23 09:28:43 2017

@author: S.Y. Agustsson
"""

import sys
from PyQt5 import QtWidgets as qw, QtCore as qc, uic
import cv2
from BeamProfilerLib.BeamProfilerUI import Ui_MainWindow
from BeamProfilerLib.gui import get_frame, get_devicelist, accumulate_frames, set_pixel_coloring
from BeamProfilerLib import genericfunctions as gfs
import time
import numpy as np
import pyqtgraph as pg

def main_old():
    app = qw.QApplication(sys.argv)
    w = BeamProfilerMainApp()
    # w.setGeometry(300, 100, 640, 480)
    w.show()
    app.exec_()

def main():
    # used to see errors generated by PyQt5 in pycharm:
    sys._excepthook = sys.excepthook
    # Set the exception hook to our wrapping function
    sys.excepthook = my_exception_hook

    app = qc.QCoreApplication.instance()
    if app is None:
        app = qw.QApplication(sys.argv)
    # Create handle prg for the Graphic Interface
    prg = BeamProfilerMainApp()
    prg.show()

    try:
        app.exec_()
    except:
        print('exiting')


def my_exception_hook(exctype, value, traceback):
    # Print the error and traceback
    print(exctype, value, traceback)
    # Call the normal Exception hook after
    sys._excepthook(exctype, value, traceback)
    sys.exit(1)


class BeamProfilerMainApp(qw.QMainWindow, Ui_MainWindow):

    CAMERA_INDEX = 1
    FPS_REFRESH_RATE = 1

    def __init__(self):
        super(BeamProfilerMainApp, self).__init__()

        self.setupUi(self)

        self.devicedict = {}
        self.init_devices()

        self.video_timer = qc.QTimer()
        self.video_timer.setInterval(10)
        self.video_timer.timeout.connect(self.on_video_timer)
        self.video_timer.start()
        self.frame = None
        self.fps = []
        self.camera = cv2.VideoCapture(self.CAMERA_INDEX)
        self.camera_is_on = False




        # setup pyqtgraph
        pg.setConfigOptions(antialias=True)

        self.show()

    def init_devices(self):
        self.devicedict = get_devicelist()
        for key, item in self.devicedict.items():
            self.select_device_combobox.addItem(key)

    def init_camera(self):
        # if isinstance(self.camera, cv2.VideoCapture()):
        #     del self.camera
        self.camera = cv2.VideoCapture(self.CAMERA_INDEX)

    @qc.pyqtSlot()
    def select_device(self):
        self.video_timer.stop()
        time.sleep(0.1)

        self.camera_name = self.select_device_combobox.currentText()

        self.CAMERA_INDEX = self.devicedict[self.camera_name]['port']
        resolution = self.devicedict[self.camera_name]['resolution']
        gfs.dictprint(self.devicedict)
        self.resolution_x_text.setText(str(int(resolution[0])))
        self.resolution_y_text.setText(str(int(resolution[1])))
        self.average_frame = np.float32(resolution)
        print('using camera {0} - {1}'.format(self.CAMERA_INDEX, self.camera_name))
        print(self.select_device_combobox.currentText())
        self.init_camera()
        self.video_timer.start()

    @qc.pyqtSlot()
    def on_video_timer(self):

        t0 = time.time()
        if self.camera_is_on:
            self.refresh_videoframe()
        t1 = time.time()

        try:
            self.fps.append(1./(t1-t0))
        except ZeroDivisionError:
            pass
        if len(self.fps) == self.FPS_REFRESH_RATE:
            fps = np.average(self.fps)
            self.fps_LCD.display(int(fps))
            self.fps = []




    def refresh_videoframe(self, _return=False):  # todo: work on this
        # frame = get_frame(self.camera, color='RGB')
        # if self.alpha_radiobutton.isChecked():
        #     alpha = self.alpha_persistence_slide.value()/10
        #     self.frame = accumulate_frames(self.camera, self.average_frame, method='accumulateSquare', alpha=alpha)
        # else:
        self.frame = get_frame(self.camera, color='RGB')

        if len(self.frame[0][0]) == 3:
            self.cam_window.setImage(self.frame, axes={'x': 1, 'y': 0, 'c': 2})
        else:
            print(len(self.frame[0][0]))
            self.cam_window.setImage(self.frame, axes={'x': 1, 'y': 0})

        if _return:
            return self.frame

    @qc.pyqtSlot()
    def save_screenshot(self):
        print('it works: save screenshot')
        saveframe = self.frame
        filename = gfs.choose_save_filename(initialdir='c://')
        gfs.save_obj(saveframe,filename)
        print('Saved frame as: {}'.format(filename))

    @qc.pyqtSlot()
    def start_recording(self):
        print('it works: start recording')

    @qc.pyqtSlot()
    def startstop_videostream(self):
        print('it works: start aquisition')
        self.camera_is_on = not self.camera_is_on
        #
        # if self.camera_is_on:
        #     self.camera_is_on = False
        # else:
        #     self.camera_is_on = True
        #
        print('Timer Started')

if __name__ == "__main__":

    recompile = True
    if recompile:
        print('recompiling')
        ui_file = 'C:\py_code\BeamProfiler\BeamProfilerLib\BeamProfilerUI.ui'
        ui_dir = 'C:\py_code\BeamProfiler\BeamProfilerLib'
        # py_file = open('C:\py_code\BeamProfiler\BeamProfilerLib\BeamProfilerUI.py', 'w')
        uic.compileUiDir(ui_dir, execute=True)
        print('done')

    main()
